?coef
?lmer
terms(fm01ML)
terms(fm01ML, "fixed")
terms(fm01ML, fixed.only =TRUE)
j <- coef(fm01ML)
head(j)
fm01ML
head(fitted(fm01ML))
?coef.merMod
?predict.merMod
predict(fm01ML)
predict(fm01ML, ~0)
predict(fm01ML, re.form=~0)
predict(fm01ML, re.form=~(1|herd))
predict(fm01ML, re.form=~(1|Batch))
fm01ML
y.star <- simulate(fm01ML, nsim = 10)
model.star <- lapply(y.star, refit, object = model)
model.star <- lapply(y.star, refit, object = fm01ML)
model.star
y.star
class(y.star)
model.star <- lapply(y.star, refit, object = fm01ML)
model.star
length(model.star)
fixef
methods("fixef")
bootMer
mod.vec <- seq_along(model.star)
mod.vec
lapply(model.star, fixef)
bootMer
ls()
model.star
t.star <- lapply(model.star, fixef)
do.call("rbind", t.star)
do.call("rbind", t(t.star))
bootMer
parametric2 <- function(model, fn, FUN, B){#
  FUN <- match.fun(FUN)#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("rbind", t.star)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, statistic = FUN, #
                        sim = "parametric", call = match.call()), class = "boot")#
  return(RES) # maybe a good thing to return?#
}
parametric2(fm01ML, FUN = fixef, B = 100)
library(boot)
j <- parametric2(fm01ML, FUN = fixef, B = 100)
j
ls()
boo01
str(boo01)
?boot
bootMer
parametric2 <- function(model, fn, FUN, B){#
  FUN <- match.fun(FUN)#
  mle <- list(beta = getME(x,"beta"), theta = getME(x,"theta"))#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("rbind", t.star)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call(),#
                        ran.gen = "simulate(<lmerMod>, 1, *)", mle = mle), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
}
j <- parametric2(fm01ML, FUN = fixef, B = 100)
parametric2 <- function(model, fn, FUN, B){#
  FUN <- match.fun(FUN)#
  mle <- list(beta = getME(model, "beta"), theta = getME(model, "theta"))#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("rbind", t.star)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call(),#
                        ran.gen = "simulate(<lmerMod>, 1, *)", mle = mle), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
}
j <- parametric2(fm01ML, FUN = fixef, B = 100)
j
j <- parametric2(fm01ML, FUN = fixef, B = 10)
print(j)
fm01ML
fixef(fm01ML)
debug(parametric2)
print(j)
j <- parametric2(fm01ML, FUN = fixef, B = 10)
FUN
mle
t0
t.star
RES
str(RES)
str(RES$t)
Q
parametric2 <- function(model, fn, FUN, B){#
  FUN <- match.fun(FUN)#
  mle <- list(beta = getME(model, "beta"), theta = getME(model, "theta"))#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("rbind", t.star)#
  rownames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call(),#
                        ran.gen = "simulate(<lmerMod>, 1, *)", mle = mle), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
}
j <- parametric2(fm01ML, FUN = fixef, B = 10)
parametric2 <- function(model, fn, FUN, B){#
  FUN <- match.fun(FUN)#
  mle <- list(beta = getME(model, "beta"), theta = getME(model, "theta"))#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("rbind", t.star)#
  colnames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call(),#
                        ran.gen = "simulate(<lmerMod>, 1, *)", mle = mle), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
}
j <- parametric2(fm01ML, FUN = fixef, B = 10)
j
debug(parametric2)
j <- parametric2(fm01ML, FUN = fixef, B = 10)
t.star
j
parametric2 <- function(model, fn, FUN, B){#
  FUN <- match.fun(FUN)#
  mle <- list(beta = getME(model, "beta"), theta = getME(model, "theta"))#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("cbind", t.star)#
  colnames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call(),#
                        ran.gen = "simulate(<lmerMod>, 1, *)", mle = mle), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
}
j <- parametric2(fm01ML, FUN = fixef, B = 10)
parametric2 <- function(model, fn, FUN, B){#
  FUN <- match.fun(FUN)#
  mle <- list(beta = getME(model, "beta"), theta = getME(model, "theta"))#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("cbind", t.star)#
  rownames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call(),#
                        ran.gen = "simulate(<lmerMod>, 1, *)", mle = mle), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
}
j <- parametric2(fm01ML, FUN = fixef, B = 10)
j
boo01
j <- parametric2(fm01ML, FUN = fixef, B = 1000)
j
boot.ci(j)
?bootMer
boot.ci(j, index=1, type=c("norm", "basic", "perc")))
boot.ci(j, index=1, type=c("norm", "basic", "perc"))
boot.ci(j, index=2, type=c("norm", "basic", "perc"))
parametric2 <- function(model, fn, FUN, B){#
  FUN <- match.fun(FUN)#
  mle <- list(beta = getME(model, "beta"), theta = getME(model, "theta"))#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("cbind", t.star)#
  rownames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
}
j <- parametric2(fm01ML, FUN = fixef, B = 100)
j
str(j)
?bot
?boot
bootMer
?plyr
library(plyr)
?llply
parametric2 <- function(model, fn, FUN, B){#
  # QUESTION: are fn and FUN both for functions? If so, let's pick one.#
  FUN <- match.fun(FUN)#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("cbind", t.star)#
  rownames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter. llply also can create a progress bar#
}
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 100))
?ldply
parametric2 <- function(model, fn, FUN, B){#
  # QUESTION: are fn and FUN both for functions? If so, let's pick one.#
  FUN <- match.fun(FUN)#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- llply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- FUN(model)#
  t.star <- llply(model.star, FUN)#
  t.star <- do.call("cbind", t.star)#
  rownames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter. llply also can create a progress bar#
}
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 100))
bootMer
simulate
methods("simulate")
lme4:::simulate.merMod
lme4::.simulateFun
install.packages("foreach")
parametric2 <- function(model, fn, FUN, B, .parallel = TRUE){#
  # QUESTION: are fn and FUN both for functions? If so, let's pick one.#
  FUN <- match.fun(FUN)#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- llply(y.star, refit, object = model, .parallel = .parallel)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- FUN(model)#
  t.star <- llply(model.star, FUN, .parallel = .parallel)#
  t.star <- do.call("cbind", t.star)#
  rownames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter. llply also can create a progress bar#
}
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 100))
?setup_parallel
library(foreach)
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 100))
?setp_parallel
?setup_parallel
setup_parallel()
j
install.packages("doMC")
library(doMC)
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 100))
library(doParallel)
install.packages("doParallel")
library(doParallel)
nodes <- detectCores()#
cl <- makeCluster(nodes)#
registerDoParallel(cl)
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 100))
?makeCluster
stopCluster()
stopCluster(cl)
library(mclapply)
library(multicore)
install.packages("multicore")
library(multicore)
help(package="parallel")
parametric2 <- function(model, fn, FUN, B, .parallel = TRUE){#
  # QUESTION: are fn and FUN both for functions? If so, let's pick one.#
  FUN <- match.fun(FUN)#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- mclapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- FUN(model)#
  t.star <- mclapply(model.star, FUN)#
  t.star <- do.call("cbind", t.star)#
  rownames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter. llply also can create a progress bar#
}
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 100))
help(package="parallel")
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 1000))
parametric <- function(model, fn, FUN, B){#
  # QUESTION: are fn and FUN both for functions? If so, let's pick one.#
  FUN <- match.fun(FUN)#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("cbind", t.star)#
  rownames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter, but it might be slower than using mclapply, which is #
  #       found in the parallel package.#
}
system.time(j <- parametric(fm01ML, FUN = fixef, B = 1000))
parametric2 <- function(model, fn, FUN, B){#
  # QUESTION: are fn and FUN both for functions? If so, let's pick one.#
  FUN <- match.fun(FUN)#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- FUN(model)#
  t.star <- lapply(model.star, FUN)#
  t.star <- do.call("cbind", t.star)#
  rownames(t.star) <- names(t0)#
  # QUESTION: Is it faster to use only one lapply statement? It should be... try it.#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter, but it might be slower than using mclapply, which is #
  #       found in the parallel package.#
}
fm01ML
system.time(j <- parametric(fm01ML, FUN = fixef, B = 100))
parametric
system.time(j <- parametric(fm01ML, FUN = fixef, B = 100))
j
boot.ci(j, index=1, type=c("norm", "basic", "perc"))
parametric2
parametric3
parametric2 <- function(model, fn, FUN, B, .parallel = TRUE){#
  # QUESTION: are fn and FUN both for functions? If so, let's pick one.#
  FUN <- match.fun(FUN)#
  model.fixef <- fixef(model) # Extract fixed effects#
  fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- mclapply(y.star, refit, object = model)#
  # TODO: How to piece everything back together and what to return?#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- FUN(model)#
  t.star <- mclapply(model.star, FUN)#
  t.star <- do.call("cbind", t.star)#
  rownames(t.star) <- names(t0)#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = FUN, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter. llply also can create a progress bar#
}
system.time(j <- parametric(fm01ML, FUN = fixef, B = 100))
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 100))
system.time(j <- parametric2(fm01ML, FUN = fixef, B = 1000))
lapply
boot
?boot
bootstrap
methods("boot")
bootstrap
?boot
?ddply
?plyr
parametric <- function(model, fn, B){#
  fn <- match.fun(fn)#
  model.fixef <- fixef(model) # Extract fixed effects#
  # fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
  model.star <- lapply(y.star, refit, object = model)#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- fn(model)#
  # Consider: lapply(___, FUN = function(x){fn(refit( ))})#
  # llapply may be faster than lapply for nonparallelized code#
  t.star <- lapply(model.star, fn)#
  # New lapply statement#
   t.star <- lapply(y.star, function(x) {#
    fn(refit(object = model, newresp = x))#
  })#
  t.star <- do.call("cbind", t.star) # Can these be nested?#
  rownames(t.star) <- names(t0)#
  # QUESTION: Is it faster to use only one lapply statement? It should be... try it.#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = fn, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter, but it might be slower than using mclapply, which is #
  #       found in the parallel package.#
}
library(lme4)
library(boot)
?merBoot
?bootMer
fm01ML <- lmer(Yield ~ 1|Batch, Dyestuff, REML = FALSE)
parametric(fm01ML, fn = fixef, B = 100)
bootMer(fm01ML, FUN = fixef, nsim = 100)
system.time(bootMer(fm01ML, FUN = fixef, nsim = 100))
system.time(parametric(fm01ML, fn = fixef, B = 100))
bootMer
parametric <- function(model, fn, B){#
  fn <- match.fun(fn)#
  model.fixef <- fixef(model) # Extract fixed effects#
  # fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
#  model.star <- lapply(y.star, refit, object = model)#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- fn(model)#
  # Consider: lapply(___, FUN = function(x){fn(refit( ))})#
  # llapply may be faster than lapply for nonparallelized code#
#  t.star <- lapply(model.star, fn)#
  # New lapply statement#
   t.star <- lapply(y.star, function(x) {#
    fn(refit(object = model, newresp = x))#
  })#
  t.star <- do.call("cbind", t.star) # Can these be nested?#
  rownames(t.star) <- names(t0)#
  # QUESTION: Is it faster to use only one lapply statement? It should be... try it.#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = fn, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter, but it might be slower than using mclapply, which is #
  #       found in the parallel package.#
}
system.time(bootMer(fm01ML, FUN = fixef, nsim = 100))
system.time(parametric(fm01ML, fn = fixef, B = 100))
system.time(parametric(fm01ML, fn = fixef, B = 100))
system.time(parametric(fm01ML, fn = fixef, B = 100))
install.packages("rbenchmark")
library(rbenchmark)
library(plyr)
parametric2 <- function(model, fn, B){#
  fn <- match.fun(fn)#
  model.fixef <- fixef(model) # Extract fixed effects#
  # fn.star <- rep(0, B)#
  # model.star <- c(1:B) # we don't need to initialize this is we use apply statements#
  # Can I just simulate multiple times and run refit once on the entire array#
  # to just get a returned array#
  y.star <- simulate(model, nsim = B)#
#  model.star <- lapply(y.star, refit, object = model)#
  # TODO: evaluate FUN for each refitted model to extract desired component.#
  # Below is one idea that will be compatible with the boot package (for CIs)#
  t0 <- fn(model)#
  # Consider: lapply(___, FUN = function(x){fn(refit( ))})#
  # llapply may be faster than lapply for nonparallelized code#
#  t.star <- lapply(model.star, fn)#
  # New lapply statement#
   t.star <- llply(y.star, function(x) {#
    fn(refit(object = model, newresp = x))#
  })#
  t.star <- do.call("cbind", t.star) # Can these be nested?#
  rownames(t.star) <- names(t0)#
  # QUESTION: Is it faster to use only one lapply statement? It should be... try it.#
  RES <- structure(list(t0 = t0, t = t(t.star), R = B, data = model@frame, #
                        seed = .Random.seed, statistic = fn, #
                        sim = "parametric", call = match.call()), #
                        class = "boot")#
  return(RES) # maybe a good thing to return?#
  # TODO: once we have things working, think about parallelization.#
  #       using an llply statement would make this easy with the .parallel #
  #       parameter, but it might be slower than using mclapply, which is #
  #       found in the parallel package.#
}
system.time(parametric2(fm01ML, fn = fixef, B = 100))
system.time((parametric2(fm01ML, fn = fixef, B = 100)))
system.time((parametric2(fm01ML, fn = fixef, B = 100)))
system.time((parametric2(fm01ML, fn = fixef, B = 100)))
system.time(parametric2(fm01ML, fn = fixef, B = 100))
?rbenchmark
system.time(parametric(fm01ML, fn = fixef, B = 100))
system.time(bootMer(fm01ML, FUN = fixef, nsim = 100))
rbenchmark(ours = parametric(fm01ML, fn = fixef, B = 100), bootMer = bootMer(fm01ML, FUN = fixef, nsim = 100))
benchmark(ours = parametric(fm01ML, fn = fixef, B = 100), bootMer = bootMer(fm01ML, FUN = fixef, nsim = 100))
library(HLMdiag)
?HLMdiag
data(Exam, package = 'mlmRev')#
fm <- lmer(normexam ~ standLRT * schavg + (standLRT | school), Exam)
fm
bootMer(fm, fixef, 10)
bootMer(fm, fixef, 100)
system.time(bootMer(fm, fixef, 100))
system.time(parametric(fm, fn=fixef, B=100))
set.seed(123)
system.time(parametric(fm, fn=fixef, B=100))
set.seed(123)
parametric(fm, fn=fixef, B=100)
bootMer(fm, fixef, 100, seed = 123)
j <- parametric(fm, fn=fixef, B=100)
plot(j)
?plot.boot
plot(j, index = 2)
plot(j, jack = TRUE)
install.packages("papeR")
library(papeR)
confint.lme
?papeR
papeR:::confint.lme
library(arm)
install.packages("arm")
library(arm)
arm::sim
arm:::sim
arm:::sim.lme
arm:::sim.lmer
methods("sim")
?arm
help(package="arm")
refit
methods("refit")
lme4:::refit.merMod
?simulate.lme
orthSim <-#
   simulate.lme(list(fixed = distance ~ age, data = Orthodont,#
                     random = ~ 1 | Subject), nsim = 1000,#
                m2 = list(random = ~ age | Subject))
orthSim <-#
   simulate.lme(list(fixed = distance ~ age, data = Orthodont,#
                     random = ~ 1 | Subject), nsim = 10,#
                m2 = list(random = ~ age | Subject))
orthSim
orthSim
simulate.lme
class(fm)
?bootMer
fm
class(fm)
class(fm) == "merMod"
?merMod
?WWGbook
library(WWGbook)
library("WWGbook")
install.packages("WWGbook")
library(WWGbook)
?WWGbook
help(package="WWGbook")
